# 饿了吗新冠疫情骑士行为预估算法大赛
比赛信息https://tianchi.aliyun.com/competition/entrance/231777/introduction

名次：三等奖
## 初赛（第18名）
### 方案总体思路
#### 骑士动作预测
骑手在面临行为决策时，存在多个待取订单和多个待送订单，我们团队将骑手行为预测问题分为两个阶段进行解决。
1. 阶段一：骑手决策时，先考虑从多个需要取的订单中选出最有可能取的订单，和从多个需要送的订单中选出最有可能送的订单，称之为“选单阶段”
2. 阶段二：骑手在经过阶段一的选单后，进行取单还是送单的决策，确定最终的行为，称之为“决策阶段”
![enter image description here](https://tianchi-public.oss-cn-hangzhou.aliyuncs.com/public/files/forum/159117400058952081591173998600.png)
#### 骑士时间预测
对于行为时间的预测，原本想采用回归模型进行拟合的，由于时间关系，以及初赛只看行为预测准确率，因此仅通过计算实际时间与理论时间（距离除以骑手速度）的差值的平均值，进行处理。
### 算法具体介绍
#### 阶段一：选单算法模型
首先对数据进行预处理，分为取单数据和送单数据，并将提供的多个表的信息进行整合。

取单数据和送单数据又进一步进行分成了一个待取订单，两个待取订单、三个待取订单、四个及以上待取订单，一个待送订单，两个待送订单、三个待送订单、四个及以上待送订单，8类数据。

只有一个订单时，直接选择；多于三个待选订单时，这部分数据较少，处理也比较麻烦，因此直接考虑选择距离最近的订单。

双待取订单，根据骑手与两个订单取单商家位置的距离差是否为0，分为两类数据。距离差不为0的数据，根据数据分析，发现，当待取订单距离差大于1500米时，此时根据距离大小直接选择订单，正确率95%左右，因此这些情况下，模型只通过距离差进行选择订单。剩余距离差不为0数据和距离差为0的数据分别通过随机森林建模，得到**双取单距离差为0模型**和**双取单距离差不为0模型**。

双待送订单，根据骑手与两个订单送达客户位置的距离差是否为0，分为两类数据。距离差不为0的数据，根据数据分析，发现，当待送订单距离差大于1000米时，此时根据距离大小直接选择订单，正确率95%左右，因此这些情况下，模型只通过距离差进行选择订单。剩余距离差不为0数据和距离差为0的数据分别通过随机森林建模，得到**双送单距离差为0模型**和**双送单距离差不为0模型**。

三待取订单，根据骑手与三个订单取单商家位置的距离差是否都为0，还是部分为0，分为3类情况，分别采用随机森林进行建模，得到**三取单距离差都为0模型**、**三取单距离差都不为0模型**、和**三取单距离差部分为0模型**。

三待送订单，根据骑手与三个订单送单客户位置的距离差是否都为0，还是部分为0，分为3类情况。由于距离差都为0的数据较少，因此直接通过订单的承诺送达时间大小进行选择。距离差都不为0和部分为0，分别采用随机森林进行建模，得到**三送单距离差都不为0模型**、和**三送单距离差部分为0模型**。

以上的模型都是采用随机森林构建，共得到9个模型，特征为订单之间的**理论完成时间差**、**订单分配时间差**、**订单可取时间差**、**订单承诺送达时间差**等差值的全部或者部分，模型参数没有进行详细的调参优化。同时可以尝试采用其他的算法模型，由于时间关系，选择了不太需要调参的随机森林。

#### 阶段二：决策算法模型
通过阶段一的选单过程后，骑手面临取单还是送单的二选一决策，是个二分类问题。

通过统计发现，当骑手与取单位置与送单位置的距离差大于1200时，此时根据距离大小，进行决策，能够达到95%的正确率，因此这种情况下，直接根据距离进行决策

当距离差小于1200时，根据距离差区间[0,100],[101,300],[301,1200],[-1200,-400],[-399,-200],[-199,-100],[-99,0],划分为7类数据，分别采用随机森林建模，特征仍然采用取单和送单之间的**理论完成时间差**、**订单分配时间差**、**订单可取时间差**、**订单承诺送达时间差**等差值。训练时，排除掉阶段一选单错误的数据。
## 复赛（第5名）
### 方案总体思路
主要思路，让骑士尽可能在一个小范围商家区域内取单，每个只取用户距离比较相近的单子，取完一些订单后，在统一进行送单。这样骑士就尽可能在起点终点两点直线配送。
因此需要对商圈内的商家进行聚类，以及商家对应的用户进行聚类。同时，由于不同的商家，订单产生量在时间上有差异，比如有的是卖早餐，有的卖午餐，用户群体不同，学生，上班白领，用餐时间也有差异。因此引入时间变量，不同时间段内单独进行聚类。整体方案由**动态区域划分的规则模型**和**调度模型**构成，详细思路如下图所示。

![enter image description here](https://tianchi-public.oss-cn-hangzhou.aliyuncs.com/public/files/forum/159117553022473461591175524900.png)
### 算法具体介绍
#### 动态区域划分的规则模型
动态区域划分的规则模型，是通过对历史数据进行挖掘。


 1. 时间区域划分
我们按照等订单量原则，将调度时间划分为了5个区间段。实际上应该划分为多少个时间区段，是需要尝试，根据实验结果确定，甚至不同的商圈应该设置不同，由于时间关系，仅是简单取了个5。
 2. 商家聚类模型
采用“Kmeans”算法，根据商家的**经纬度**和**订单产生频率**，其实就是根据所有订单的商家**经纬度**进行聚类。聚类个数基本都为9个，个别设置了7个，9个，聚类个数也是需要实验确定，我们做了几组实验，最后确定了9个相对比较好，由于本地有3个商圈的测试数据，因此我们对这三个进行了实验，单独确定了它们的聚类个数。
 3. 客户距离模型
同样采用“Kmeans”算法，不同的是，以每个商家簇的聚类中心为原点，将客户的经纬度转化为极坐标，以**角度**进行聚类，使骑士从该商家簇出发，沿某一个方向进行送单。聚类个数基本设置为9个。
 4. 骑士额定取单容量
 骑手额定取单容量指的是骑士取完多少个订单后，开始进行送单。根据数据统计，订单量随着调度时间增加，逐渐上升，因此我们设置额定取单容量前期小后期大，从1-3逐渐增加。原来应该是不同的商家簇的客户簇单独设置骑士的额定取单容量，但是这样的话参数会变得特别多，一个一个的去寻找最优值，会耗费很多时间精力，因此我们简化成了，只随时间而变化。

**注意**：在实际操作过程中，由于团队内部沟通理解上的失误，导致我们在聚类模型的训练中，没有考虑订单产生频率，我们筛掉了重复位置的数据，因此原本聚类模型应该是不同的时间段，由于订单产生频率不同，得到的模型也不同，变成了在整个调度时间轴上，保持不变，这影响了我们后面的成绩。
#### 调度模型

 1. 调度时刻
 我们采用两分钟进行一次调度
 
 2. 给商家簇分配骑士策略
 根据商家簇所需的最大骑士容量和最小骑士容量与当前可调度骑士的数量关系，就近原则按需分配。
 所需骑士最大容量：当前调度时间区段内，该商家簇可能产生的订单总量。根据历史数据统计得到。
 所需骑士最小容量：当前调度时刻，该商家簇现在尚存未分配的订单数量。
 当商圈的最小骑士容量和小于可调度骑士数量时，根据每个商家簇的最小骑士容量一一分配骑士，多余骑士按照所需最大骑士容量比例进行分配。
 当商圈的最小骑士容量和小于可调度骑士数量时，此时骑士数量不够分，只能根据商家簇的所需最小骑士容量的比例进行分配。
 
 3. 订单分配给骑士的策略
 每个商家簇，都有各自拥有的骑士，根据订单可以取单时间的大小，由小到大排序，依次分配给骑士，骑士只接收一个客户簇的所有订单。若订单没有合适的骑士，则保留至下一轮的调度。
 
 4. 骑士到店取单规划
 当骑士接到的订单小于4时，采用穷举的方式，选择耗时最少的到店取单动作顺序，大于4时，根据订单与骑士的距离由近到远进行取单。
 
 5. 判断骑士是否该进入送单状态
 当骑士接到的订单数大于等于设置的额定取单量，骑士进入送单状态，或者虽然未达到额定取单量，但是骑士已经完成了当前接到的所有订单的取单动作，也进入送单状态。进入送单状态的骑士，只送单，不接新订单，直到送完所有订单后，重新纳入可调度骑士，重新进行分配给商家簇。
 
 6. 骑士送单规划
 当骑士待送订单大于4时，根据距离从近到远进行送单，订单小于等于4时，采用穷举，选择超时单数最少的送单顺序组合。

